"""
Pick training sets from databased generated by basinhopping

"""
import os,sys
from ase import Atoms, Atom, units
import ase.io
import numpy as np

def read_eon(filename,state_number = None, mode = None):
    f = open(filename,'r')
    imgs = []
    while True:
        elements = []
        positions = []
        line = f.readline()
        if not line:
           break
        #read head lines
        f.readline()
        line = f.readline()
        cell_sizes = [float(field) for field in line.split()]
        #print cell_sizes
        line = f.readline()
        cell_angles = [float(field) for field in line.split()]
        #print cell_angles
        f.readline()
        f.readline()
        numb_species = int(f.readline().split()[0])
        numb_atoms = [int(field) for field in f.readline().split()]
        f.readline()
        #read one particular structure assinged by state_number
        for i in range(numb_species):
          element = f.readline().split()[0]
          line = f.readline()
          for j in range (numb_atoms[i]):
              line = f.readline()
              fields = line.split()
              elements.append(element)
              positions.append( [ float(fields[k]) for k in range(3) ] )
        elements = np.array(elements)
        positions = np.array(positions)
        p = Atoms(elements, positions=positions)
        p.set_cell([[20.,0,0],[0,20.,0],[0,0,20.]],scale_atoms=False)
        p.set_pbc((True, True, True))
        #cm = p.get_center_of_mass()
        #cm_o = np.array([0.,0.,0.])
        #p.translate(cm_o - cm)
        #image = [p, energy]
        #local_minimum[cycle]=[image,[]]
        #cycle += 1
        p.center()
        imgs.append(p)
    f.close()
    return imgs

args = sys.argv
imgs = read_eon(args[1])
from ase.io import Trajectory
#opt_traj = Trajectory('train.traj', 'w')
ase.io.write(filename='traj.xyz', images= imgs, format='xyz')
Pds = [p.index for p in imgs[0] if p.symbol == 'Pd']
Hs = [p.index for p in imgs[0] if p.symbol == 'H']
for p in imgs:
   min_HPd = 10.0
   min_PdPd = 10.0
   for Pd in Pds:
      for H in Hs:
         dist = p.get_distance(H,Pd)
         if dist < min_HPd :
            min_HPd = dist
      for Pd_2 in Pds:
         if Pd < Pd_2:
           dist = p.get_distance(Pd,Pd_2)
           if dist < min_PdPd :
              min_PdPd = dist

   print "{:12.6f} {:12.6f} {:12.6f}".format(p.get_distance(0,1), min_HPd, min_PdPd)

"""
Pick training sets from databased generated by basinhopping

"""
import os,sys
from ase import Atoms, Atom, units
import ase.io
import numpy as np
from ase.optimize.lbfgs import LBFGS
from ase.optimize.fire import FIRE
#from ase.calculators.lammpslib import LAMMPSlib
#from tsase.calculators.lmplib import LAMMPSlib
from ase.calculators.emt import EMT
from ase.md.langevin import Langevin
from ase.lattice.surface import fcc110
from ase.md.velocitydistribution import MaxwellBoltzmannDistribution
from ase.md import VelocityVerlet
from ase.constraints import FixAtoms
from expectra.atoms_operator import match
from expectra.atoms_operator import match
from amp import Amp
from amp.descriptor.gaussian import Gaussian, make_symmetry_functions
from amp.descriptor.cutoffs import Cosine,Polynomial
from amp.model.neuralnetwork import NeuralNetwork
from amp.model import LossFunction
from set_forces import force_setter

def read_local(filename,state_number = None, mode = None):
    f = open(filename,'r')
    local_minimum = {}
    ener = []
    cycle = 0
    while True:
        elements = []
        positions = []
        line = f.readline()
        if not line:
           break
        if cycle == 0:
           atom_numb = int(line.split()[0])
        line = f.readline()
        energy = (float(line.split()[0]))
        #read one particular structure assinged by state_number
        for i in range (atom_numb):
            line = f.readline()
            fields = line.split()
            elements.append(fields[0])
            positions.append( [ float(fields[j+1]) for j in range(3) ] )
        elements = np.array(elements)
        positions = np.array(positions)
        ener.append(energy)
        p = Atoms(elements, positions=positions)
        p.set_cell([[20.,0,0],[0,20.,0],[0,0,20.]],scale_atoms=False)
        p.set_pbc((True, True, True))
        cm = p.get_center_of_mass()
        cm_o = np.array([0.,0.,0.])
        p.translate(cm_o - cm)
        image = [p, energy]
        local_minimum[cycle]=[image,[]]
        cycle += 1
    f.close()
    return local_minimum


def read_images(filename,local_minimum={}):
    f = open(filename,'r')
    atoms = []
    ener = []
    cycle = -1
    while True:
        elements = []
        positions = []
        forces = []
        line = f.readline()
        if not line:
           break
        if cycle == -1:
           atom_numb = int(line.split()[0])
        line = f.readline()
        if 'local' in line:
           local = True 
           matched = False
        else:
           local = False
           matched = False
        energy = (float(line.split(":")[1]))
        #read one particular structure assinged by state_number
        for i in range (atom_numb):
            line = f.readline()
            fields = line.split()
            elements.append(fields[0])
            positions.append( [ float(fields[j+1]) for j in range(3) ] )
            forces.append( [ float(fields[j+1]) for j in range(3,6) ] )
        elements = np.array(elements)
        positions = np.array(positions)
        ener.append(energy)
        p = Atoms(elements, positions=positions)
        p.set_cell([[20.,0,0],[0,20.,0],[0,0,20.]],scale_atoms=False)
        p.set_pbc((True, True, True))
        image = [p, energy,np.array(forces)]
        if local:
           for key in local_minimum:
              if abs(energy - local_minimum[key][0][1]) < 0.002:
#                 if match(image[0], local_minimum[key][0][0], 0.2, 1.3, True, False):
                    local_minimum[key][0]=image
                    local_minimum[key][1].extend(atoms)
                    matched = True
                    break
           if not matched:
              print 'new local:', energy
#              if energy < -16.0:
#                 ase.io.write(filename='not_matched.xyz', images= p, format='xyz')
           atoms = []
        else:
           atoms.append(image)
        cycle += 1
    f.close()
    return local_minimum, np.array(ener)

args = sys.argv
local_minimum_o = read_local(args[1])
local_minimum,ener = read_images(args[2], local_minimum_o)

from operator import itemgetter
images_training = []

from ase.io import Trajectory
opt_traj = Trajectory('train.traj', 'w')
interval = 100
split_e = -12.0
discard_e = -8.0
total = 0

upper_needed = 30
lower_needed = 270
selected = 0
e_writter = open('e_log.dat', 'w')

for key in local_minimum:
   if local_minimum[key][0][1] > -14.0:
      continue
   #sort images with energy from low to high
   local_minimum[key][1]=sorted(local_minimum[key][1], key=itemgetter(1))

   images = local_minimum[key][1]
   upper_e_numb = np.sum(1 for i in images if i[1] > split_e and i[1] < discard_e)
   lower_e_numb = np.sum(1 for i in images if i[1] <= split_e)

   if upper_e_numb < upper_needed:
      u_interval = 1
   else:
      u_interval = int(upper_e_numb/upper_needed)

   if lower_e_numb < lower_needed:
      l_interval = 1
   else:
      l_interval = int(lower_e_numb/lower_needed)
    
   larger = 0
   smaller = 0

   #record local minimum
   p = local_minimum[key][0][0]
   calc = force_setter(energy=local_minimum[key][0][1], forces=local_minimum[key][0][2])
   p.set_calculator(calc)
   p.get_potential_energy()
   p.get_forces()
   images_training.append(p.copy())
   opt_traj.write(p)

   total+=1
   selected += 1
   e_writter.write(("%10d  %12.8f\n")%(selected, local_minimum[key][0][1]))
   for item in images:
       if item[1] > discard_e:
          continue
       if item[1] > split_e:
          larger+=1
          if larger % u_interval ==0:
             p = item[0]
             calc = force_setter(energy=item[1], forces=item[2])
             p.set_calculator(calc)
             p.get_potential_energy()
             p.get_forces()
             images_training.append(p.copy())
             opt_traj.write(p)

             selected += 1
             e_writter.write(("%10d  %12.8f\n")%(selected, item[1]))
       
       if item[1] <= split_e:
          smaller+=1
          if smaller%l_interval ==0: 
             p = item[0]
             calc = force_setter(energy=item[1], forces=item[2])
             p.set_calculator(calc)
             p.get_potential_energy()
             p.get_forces()
             images_training.append(p.copy())
             opt_traj.write(p)

             selected += 1
             e_writter.write(("%10d  %12.8f\n")%(selected, item[1]))
       total+=1
   print "Local:", key, local_minimum[key][0][1], "upper: %10d %10d", upper_e_numb,lower_e_numb, "interval: %6d %6d", u_interval, l_interval
ase.io.write(filename='train.xyz', images= images_training, format='xyz')

print "total:",total
#print ">-10:", larger,"<-10:", smaller
print "# of images for training:", len(images_training)

"""
Gs = {"C": [{"type":"G2", "element":"C", "eta":0.05},
             {"type":"G2", "element":"C", "eta":4.00},
             {"type":"G2", "element":"C", "eta":20.0},
             {"type":"G2", "element":"C", "eta":80.0},
             {"type":"G4", "elements":["C","C"],"eta":0.005, "gamma":4.0, "zeta":-1.0},
             {"type":"G4", "elements":["C","C"],"eta":0.005, "gamma":4.0, "zeta":1.0},
            ]
     }

calc = Amp(descriptor=Gaussian(Gs=Gs,
                               #cutoff=Cosine(2.5)
                               cutoff=Polynomial(gamma=5, Rc=3.0)
                               ),
           cores=24,
           model=NeuralNetwork(hiddenlayers=(50,), activation='sigmoid'))
#calc = Amp.load('amp-checkpoint.amp',cores=24)
calc.model.lossfunction = LossFunction(convergence={'energy_rmse': 0.001,
                                                    'force_rmse': 0.02},
                                        force_coefficient=0.04)
calc.train(images='train.traj')
"""
